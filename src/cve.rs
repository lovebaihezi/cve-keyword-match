use serde::{Deserialize, Serialize};
use serde_json::{Map, Value};

/*
{
    "dataType": "CVE_RECORD",
    "dataVersion": "5.0",
    "cveMetadata": {
        "cveId": "CVE-2024-0069",
        "assignerOrgId": "0dc7baee-4a9f-419f-bd0a-e21ec5dac512",
        "assignerShortName": "HYPR",
        "state": "REJECTED",
        "dateReserved": "2023-11-27T18:04:05.948Z",
        "dateRejected": "2023-11-27T23:53:15.051991Z",
        "dateUpdated": "2023-11-27T23:53:15.051991Z"
    },
    "containers": {
        "cna": {
            "providerMetadata": {
                "orgId": "0dc7baee-4a9f-419f-bd0a-e21ec5dac512",
                "shortName": "HYPR",
                "dateUpdated": "2023-11-27T23:53:15.051991Z"
            },
            "rejectedReasons": [
                {
                    "lang": "en",
                    "value": "This CVE ID was unused by the CNA."
                }
            ]
        }
    }
}‚èé
*/

#[derive(Default, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct CVEMetadata {
    cve_id: String,
    state: String,
    #[serde(flatten)]
    other: Map<String, Value>,
}

#[derive(Default, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct CVE {
    cve_metadata: CVEMetadata,
    containers: Map<String, Value>,
    #[serde(flatten)]
    other: Map<String, Value>,
}

impl CVE {
    pub fn id(&self) -> &str {
        &self.cve_metadata.cve_id
    }

    pub fn state(&self) -> &str {
        &self.cve_metadata.state
    }

    pub fn metadata(&self) -> &CVEMetadata {
        &self.cve_metadata
    }

    pub fn des(&self) -> Option<&str> {
        self.containers
            .get("cna")
            .and_then(|cna| cna.get("descriptions"))
            .and_then(|v| v.as_str())
    }
}

/*
pub fn json_to_cve(path: &PathBuf, value: &Value, keyword: &str) -> Option<CVE> {
    let regex = Regex::new(keyword).unwrap();
    let mut cve: CVE = Default::default();
    if let Some(id) = value
        .get("cveMetadata")
        .and_then(|v| v.get("cveId"))
        .and_then(|v| v.as_str())
    {
        cve.id = id.to_owned();
    } else {
        log::error!("can not get id from {:?}", &path);
        return None;
    }
    let containers = if let Some(containers) = value.get("containers").and_then(|v| v.as_object()) {
        containers
    } else {
        log::error!("no containers in path: {:?}", &path);
        return None;
    };
    for descriptions in containers
        .values()
        .flat_map(|value| value.get("descriptions").and_then(|v| v.as_array()))
    {
        for des in descriptions.iter() {
            if let Some(des_value) = des
                .get("lang")
                .and_then(|v| v.as_str())
                .is_some_and(|v| v == "en")
                .then(|| des.get("value").and_then(|v| v.as_str()))
                .flatten()
            {
                if regex.find(des_value).is_some() {
                    cve.des = des_value.trim().to_owned();
                    break;
                }
            }
        }
    }
    if cve.des.is_empty() {
        return None;
    }

    for metrics in containers
        .values()
        .flat_map(|v| v.get("metrics").and_then(|v| v.as_array()))
    {
        for metric in metrics {
            log::trace!("{:?}", metric);
            if let Some(obj) = metric
                .as_object()
                .map(|v| v.values())
                .and_then(|mut v| v.find(|v| v.is_object()))
                .and_then(|v| v.as_object())
            {
                let vec: Vec<String> = obj
                    .iter()
                    .flat_map(|(key, value)| value.as_str().map(|s| (key, s)))
                    .map(|(k, v)| format!("[{}],[{}],", k, v))
                    .collect();
                let str = vec.join("");
                let table = format!(
                    r#"
#table(
    columns: (auto, auto),
    align: horizon,
    inset: 5pt,
    {}
)"#,
                    str
                );
                cve.metric = table;
            }
        }
    }
    Some(cve)
}
*/
