use std::path::PathBuf;

use regex::Regex;
use serde_json::Value;

#[derive(Default)]
pub struct CVE {
    id: String,
    des: String,
    // pub metric: String,
}

impl CVE {
    pub fn id(&self) -> &str {
        &self.id
    }

    pub fn des(&self) -> &str {
        &self.des
    }
}

pub fn json_to_cve(path: &PathBuf, value: &Value, keyword: &str) -> Option<CVE> {
    let regex = Regex::new(keyword).unwrap();
    let mut cve: CVE = Default::default();
    if let Some(true) = value
        .get("cveMetadata")
        .and_then(|v| v.get("state"))
        .and_then(|v| v.as_str())
        .map(|v| v == "REJECTED")
    {
        log::trace!("filter out CVE cause is rejected!");
        return None;
    }
    if let Some(id) = value
        .get("cveMetadata")
        .and_then(|v| v.get("cveId"))
        .and_then(|v| v.as_str())
    {
        cve.id = id.to_owned();
    } else {
        log::error!("can not get id from {:?}", &path);
        return None;
    }
    let containers = if let Some(containers) = value.get("containers").and_then(|v| v.as_object()) {
        containers
    } else {
        log::error!("no containers in path: {:?}", &path);
        return None;
    };
    for descriptions in containers
        .values()
        .flat_map(|value| value.get("descriptions").and_then(|v| v.as_array()))
    {
        for des in descriptions.iter() {
            if let Some(des_value) = des
                .get("lang")
                .and_then(|v| v.as_str())
                .is_some_and(|v| v == "en")
                .then(|| des.get("value").and_then(|v| v.as_str()))
                .flatten()
            {
                if regex.find(des_value).is_some() {
                    cve.des = des_value.trim().replace('\n', "\\n");
                    break;
                }
            }
        }
    }
    if cve.des.is_empty() {
        return None;
    }

    /*
        for metrics in containers
            .values()
            .flat_map(|v| v.get("metrics").and_then(|v| v.as_array()))
        {
            for metric in metrics {
                log::trace!("{:?}", metric);
                if let Some(obj) = metric
                    .as_object()
                    .map(|v| v.values())
                    .and_then(|mut v| v.find(|v| v.is_object()))
                    .and_then(|v| v.as_object())
                {
                    let vec: Vec<String> = obj
                        .iter()
                        .flat_map(|(key, value)| value.as_str().map(|s| (key, s)))
                        .map(|(k, v)| format!("[{}],[{}],", k, v))
                        .collect();
                    let str = vec.join("");
                    let table = format!(
                        r#"
    #table(
        columns: (auto, auto),
        align: horizon,
        inset: 5pt,
        {}
    )"#,
                        str
                    );
                    cve.metric = table;
                }
            }
        }
    */
    Some(cve)
}
