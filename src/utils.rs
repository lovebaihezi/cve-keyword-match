use std::{
    path::{Path, PathBuf},
    sync::Arc,
};

use regex::Regex;
use serde_json::Value;

use crate::{json_to_cve, CVE};

pub fn paths(root: impl AsRef<Path>) -> std::io::Result<Vec<PathBuf>> {
    let mut dir = std::fs::read_dir(root)?;
    let mut vec = Vec::new();
    while let Some(entry) = dir.next() {
        match entry {
            Ok(de) => match de.file_type() {
                Ok(file_type) => {
                    if file_type.is_file() {
                        vec.push(de.path())
                    }
                    if file_type.is_dir() {
                        match paths(de.path()) {
                            Ok(mut pathbufs) => {
                                vec.append(&mut pathbufs);
                            }
                            Err(e) => {
                                log::error!("{}", e.to_string());
                            }
                        }
                    }
                }
                Err(e) => {
                    log::error!("{}", e.to_string());
                }
            },
            Err(e) => {
                log::error!("{}", e.to_string());
            }
        }
    }
    Ok(vec)
}

pub fn is_support_io_uring() -> bool {
    let proc = std::fs::read_to_string("/proc/kallsyms");
    match proc {
        Ok(str) => str.contains("io_uring_setup"),
        Err(e) => {
            log::error!("can't open proc kallsyms file cause {:?}!", e);
            false
        }
    }
}

pub async fn json_file_des_value_include_keyword(
    path: &PathBuf,
    keyword: &str,
) -> std::io::Result<Option<CVE>> {
    let file = std::fs::File::open(&path)?;
    let metadata = file.metadata()?;
    let file_size = metadata.len();
    if file_size > std::usize::MAX as u64 {
        log::error!(
            "can not read {:?}, cause too large for memory: {}",
            path,
            file_size
        );
        return Ok(None);
    }
    let buf = vec![0; file_size as usize];
    let file = tokio_uring::fs::File::from_std(file);
    let (size_or_err, buf) = file.read_at(buf, 0).await;
    let size = size_or_err?;
    log::trace!("read {} bytes from {:?}", size, &path);
    let cve: CVE = serde_json::from_slice(&buf[0..size])?;
    Ok(Some(cve))
}
