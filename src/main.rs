use std::path::{Path, PathBuf};

use clap::Parser;
use cve_match_keyword::{json_to_cve, CVE};
use serde_json::Value;

#[derive(Parser)]
#[command(name = "cli")]
#[command(version = "0.1")]
struct Args {
    keyword: String,
    #[arg(long, short)]
    limit: Option<usize>,
}

fn paths(root: impl AsRef<Path>) -> std::io::Result<Vec<PathBuf>> {
    let mut dir = std::fs::read_dir(root)?;
    let mut vec = Vec::new();
    while let Some(entry) = dir.next() {
        match entry {
            Ok(de) => match de.file_type() {
                Ok(file_type) => {
                    if file_type.is_file() {
                        vec.push(de.path())
                    }
                    if file_type.is_dir() {
                        match paths(de.path()) {
                            Ok(mut pathbufs) => {
                                vec.append(&mut pathbufs);
                            }
                            Err(e) => {
                                log::error!("{}", e.to_string());
                            }
                        }
                    }
                }
                Err(e) => {
                    log::error!("{}", e.to_string());
                }
            },
            Err(e) => {
                log::error!("{}", e.to_string());
            }
        }
    }
    Ok(vec)
}

async fn json_file_des_value_include_keyword(
    path: &PathBuf,
    keyword: &str,
) -> std::io::Result<Option<CVE>> {
    let file = std::fs::File::open(&path)?;
    let metadata = file.metadata()?;
    let file_size = metadata.len();
    if file_size > std::usize::MAX as u64 {
        log::error!(
            "can not read {:?}, cause too large for memory: {}",
            path,
            file_size
        );
        return Ok(None);
    }
    let buf = vec![0; file_size as usize];
    let file = tokio_uring::fs::File::from_std(file);
    let (size_or_err, buf) = file.read_at(buf, 0).await;
    let size = size_or_err?;
    log::trace!("read {} bytes from {:?}", size, &path);
    let value: Value = serde_json::from_slice(&buf[0..size])?;
    Ok(json_to_cve(path, &value, keyword))
}

fn main() -> std::io::Result<()> {
    env_logger::init();
    // TODO(chaibowen): change to iter, not read all the sub-files
    tokio_uring::start(async {
        let files = paths(".")?;
        log::info!("read from {} cve file", files.len());
        let arg: Args = clap::Parser::parse();
        let mut x = 0usize;
        let mut count = 0;
        for path in files {
            // TODO(chaibowen): consider as a task rather then run in order
            match json_file_des_value_include_keyword(&path, &arg.keyword).await {
                Ok(Some(CVE { id, des, metric })) => {
                    x += 1;
                    count += 1;
                    print!("[{}],[{}],[{}],\n", id, des, metric);
                    if let Some(limit) = arg.limit {
                        if x > limit {
                            break;
                        }
                    }
                }
                Err(e) => {
                    log::error!("failed to process {:?}, cause: {}", path, e.to_string());
                }
                _ => {}
            }
        }
        log::info!("{} cve description cantains {:?}", count, &arg.keyword);
        Ok(())
    })
}
