use std::path::{Path, PathBuf};

use clap::Parser;
use cve_match_keyword::{json_to_cve, CVE};
use futures::future::join_all;
use rayon::prelude::*;
use serde_json::Value;

#[derive(Parser)]
#[command(name = "cli")]
#[command(version = "1.0.1")]
struct Args {
    keyword: String,
    #[arg(long, short)]
    limit: Option<usize>,
}

fn paths(root: impl AsRef<Path>) -> std::io::Result<Vec<PathBuf>> {
    let mut dir = std::fs::read_dir(root)?;
    let mut vec = Vec::new();
    while let Some(entry) = dir.next() {
        match entry {
            Ok(de) => match de.file_type() {
                Ok(file_type) => {
                    if file_type.is_file() {
                        vec.push(de.path())
                    }
                    if file_type.is_dir() {
                        match paths(de.path()) {
                            Ok(mut pathbufs) => {
                                vec.append(&mut pathbufs);
                            }
                            Err(e) => {
                                log::error!("{}", e.to_string());
                            }
                        }
                    }
                }
                Err(e) => {
                    log::error!("{}", e.to_string());
                }
            },
            Err(e) => {
                log::error!("{}", e.to_string());
            }
        }
    }
    Ok(vec)
}

async fn json_file_des_value_include_keyword(
    path: &PathBuf,
    keyword: &str,
) -> std::io::Result<Option<CVE>> {
    let file = std::fs::File::open(&path)?;
    let metadata = file.metadata()?;
    let file_size = metadata.len();
    if file_size > std::usize::MAX as u64 {
        log::error!(
            "can not read {:?}, cause too large for memory: {}",
            path,
            file_size
        );
        return Ok(None);
    }
    let buf = vec![0; file_size as usize];
    let file = tokio_uring::fs::File::from_std(file);
    let (size_or_err, buf) = file.read_at(buf, 0).await;
    let size = size_or_err?;
    log::trace!("read {} bytes from {:?}", size, &path);
    let value: Value = serde_json::from_slice(&buf[0..size])?;
    Ok(json_to_cve(path, &value, keyword))
}

fn main() -> std::io::Result<()> {
    env_logger::init();
    // TODO(chaibowen): change to iter, not read all the sub-files

    let arg: Args = clap::Parser::parse();
    let files = paths(".").unwrap();
    let keyword = &arg.keyword;
    let result = tokio_uring::start(async {
        log::info!("read from {} cve file", files.len());
        let iter = files.iter().map(|path| async move {
            match json_file_des_value_include_keyword(&path, keyword).await {
                Ok(Some(cve)) => {
                    let id = cve.id();
                    let des = cve.des();
                    Some(format!("[{id}], [{des}]"))
                }
                Err(e) => {
                    log::error!("failed to process {:?}, cause: {}", path, e.to_string());
                    None
                }
                _ => None,
            }
        });
        join_all(iter).await
    });
    let res: Vec<String> = result.into_par_iter().flatten().collect();
    log::info!("{} cve description cantains {:?}", res.len(), keyword);
    Ok(())
}
