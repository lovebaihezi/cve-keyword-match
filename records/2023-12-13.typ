= 2023 12 13

== This Week

after the meeting, we should redesign the arch of the current project, like what we have done, what should be done, and the whole project structure.

Previous we have talked about the topic, what we have done just like 

Aims on

=== How to run on a large project(code base)

=== Project design

=== Current status

=== Future Ideas

== Run on a large code base(10 large code)

We use the LLVM framework to read the LLVM IR code to build our analysis application, so we need to compile every C or C++ source file into the LLVM IR file and concat them or analyze each one.

So we need to know the project's structure, which can somehow be generated from the build commands generator like `bear`, `CMake`, or `bazel`, which is widely used in large open-source repos.

Every time the generators generate the build files, we can use the `compile_commands.json` file, whose structure is just like the below: 

```json
[
  { "directory": "/home/user/llvm/build",
    "arguments": ["/usr/bin/clang++", "-Irelative", "-DSOMEDEF=With spaces, quotes and \\-es.", "-c", "-o", "file.o", "file.cc"],
    "file": "file.cc" },

  { "directory": "/home/user/llvm/build",
    "command": "/usr/bin/clang++ -Irelative -DSOMEDEF=\"With spaces, quotes and \\-es.\" -c -o file.o file.cc",
    "file": "file2.cc" },

  ...
]
```

spec: #link("https://clang.llvm.org/docs/JSONCompilationDatabase.html")[llvm spec]

We can read the generated file and use the info to compile every file into IR and analyze it.

=== Linux

Linux uses Makefile as its build system, which we can use `bear` to generate `compile_commands.json`.

=== Chromium

Chromium uses Bazel as the build tool, from the official documentation, we need to add an extension to Bazel.

=== PostgreSQL, SQLite, etc.

Same as above

== Some ways to clone many projects

= Idea

+ We will read the variables, global variables; the read-write operations of a variable; the control flow effect on read-write operations

+ The atomic item of the profile generation process is a single IR file

+ We can get all the functions, all the variables, and all the blocks(which are used by LLVM to get the DAG) that represent the control flows

// 1. Terminator Instructions: These instructions end a basic block, and every basic block must end with a terminator instruction. Examples include `ret` (return from function), `br` (branch), `switch` (multi-way branch), etc.

// 2. Binary Instructions: These instructions take two operands and produce a result that depends on the values of both operands. Examples include `add` (addition), `sub` (subtraction), `mul` (multiplication), `div` (division), etc.

// 3. Bitwise Binary Instructions: These instructions perform bitwise operations on their operands. Examples include `shl` (shift left), `lshr` (logical shift right), `ashr` (arithmetic shift right), `and` (bitwise and), `or` (bitwise or), `xor` (bitwise xor), etc.

// 4. Memory Instructions: These instructions are used to load from and store to memory. Examples include `alloca` (allocate memory on the stack), `load` (load from memory), `store` (store to memory), etc.

// 5. Other Instructions: This category includes a variety of other instructions, such as those for type conversion, comparison, etc[2][3].

+ Why we can do such a thing: the CPU will read some data, and modify some data in register or memory(which is hidden by abstract); we are building our application on LLVM IR, where each instruction's type or operation is limited(defined by enums, about 67 code, which can be found at `Instruction.def` file). We can give some rules or use rules that other program analysis tools give, we can use the same rules but with the profile we generated, we need to check if we can use it.

= Project Design

// + A CLI program that can run everywhere LLVM support

// + A CLI that has minimum third-party dependencies

= System Design

=== Techs

+ Programming Languages: Zig

+ Third Party Deps: LLVM-C

+ We can just focused on AMD64 arch, to simplify the model

+ We can build as LLVM plugin to check the source when compiling

=== Modules

==== profile content

+ the control flow graph(shall we merge the files)

==== Analyze rule(or called pattern)

Collected from other static analysis tools

We can get some rules from other analysis tools, like `llvm static analysis`, `sonar cpp analysis`

+ Pattern 1: Read some shared variables which will be modified on another thread

// === Diagram

// #include "arch-design.diagram.typ"

= Current Status

== We Can

+ We can get the BasicBlock, which represents the data control flow

+ We can get the variables, in functions, and globals.

+ We can get the direct read and write to a variable

== We Can't

+ Tag the Atomic variables, thread locals, mutexes, and atomic liked

+ Trace a variable across the block, we need to get the variable used in the current block, the write path, the read path, and the variables dependent variables' changes

= Future Ideas

== Should we integrated with the VCS(or just specific the Git)?

By using git, we can easily get the diff between the versions(we can use the tag, release commit, or branch). 

*How to acc the source code analysis based on the code changes*

*How to get more vulnerabilities by code analysis based on the code changes*

= TODOS

== Cases: Some real CVE

+ Find some CVE in real projects that related to our ideas like the code changes caused

== Some Rules from static analysis

== The dataset for experiments

== The impact of the current Idea